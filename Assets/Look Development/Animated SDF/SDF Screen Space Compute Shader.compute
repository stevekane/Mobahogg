#pragma kernel JumpFloodInit
#pragma kernel JumpFloodStep
#pragma kernel JumpFloodFinalize

RWTexture2D<float2> _JumpFloodPing;
RWTexture2D<float2> _JumpFloodPong;
RWTexture2D<float> _JumpFloodDistance;
Texture2D<float> _Mask;

int _TexWidth;
int _TexHeight;
int _Step;

float Metric(float2 a, float2 b) {
  float dx = a.x - b.x;
  float dy = a.y - b.y;
  return dx * dx + dy * dy;
}

bool Valid(float2 v) {
  return v.x >= 0;
}

bool Invalid(float2 v) {
  return v.x < 0;
}

// Pass 1: Initialize with positions of edge pixels
[numthreads(8,8,1)]
void JumpFloodInit(uint3 id : SV_DispatchThreadID)
{
  if (id.x >= _TexWidth || id.y >= _TexHeight) return;
  float mask = _Mask.Load(int3(id.xy, 0));
  _JumpFloodPing[id.xy] = mask < 0.5 ? float2(-1, -1) : float2(id.xy);
  _JumpFloodPong[id.xy] = float2(-1, -1);
}

[numthreads(8,8,1)]
void JumpFloodStep(uint3 id : SV_DispatchThreadID)
{
  if (id.x >= _TexWidth || id.y >= _TexHeight) return;

  float2 best = float2(-1, -1);
  float minDist = 99999.0;

  float2 self = _JumpFloodPing[id.xy];
  if (Valid(self)) {
    best = self;
    minDist = Metric(float2(id.xy), self);
  }

  for (int dy = -1; dy <= 1; dy++) {
    for (int dx = -1; dx <= 1; dx++) {
      if (dx == 0 && dy == 0) continue;

      int2 samplePos = id.xy + _Step * int2(dx, dy);
      if (samplePos.x < 0 || samplePos.y < 0 || samplePos.x >= _TexWidth || samplePos.y >= _TexHeight)
        continue;

      float2 candidate = _JumpFloodPing[samplePos];
      if (Invalid(candidate)) continue;

      float dist = Metric(float2(id.xy), float2(candidate));
      if (dist < minDist) {
        minDist = dist;
        best = candidate;
      }
    }
  }

  _JumpFloodPong[id.xy] = best;
}

// Pass 3: Finalize by writing signed distance
[numthreads(8,8,1)]
void JumpFloodFinalize(uint3 id : SV_DispatchThreadID)
{
  if (id.x >= _TexWidth || id.y >= _TexHeight) return;

  float2 nearest = _JumpFloodPing[id.xy];
  float mask = _Mask.Load(int3(id.xy, 0));
  float dist = nearest.x < 0 ? 0.0 : Metric(float2(id.xy), nearest);
  // _JumpFloodDistance[id.xy] = mask > 0.5 ? dist : 0.0;
  _JumpFloodDistance[id.xy] = dist;
}